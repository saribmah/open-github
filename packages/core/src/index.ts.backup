import { Hono } from "hono";
import { cors } from "hono/cors";
import { logger } from "hono/logger";
import { config, getProviderConfig } from "./config/config";
import { GitHubClient } from "./github/github";
import { SessionManager } from "./sandbox/session";
import { createSandboxProvider } from "./sandbox/sandbox";
import { formatErrorResponse } from "./utils/errors";

// Initialize components
const app = new Hono();
const githubClient = new GitHubClient(
  config.github.apiUrl,
  config.github.token,
);
const sessionManager = new SessionManager();
const sandboxProvider = createSandboxProvider(
  config.sandbox.provider,
  getProviderConfig(config),
);

// Middleware
app.use("*", logger());
app.use(
  "*",
  cors({
    origin: config.server.allowedOrigins,
    credentials: true,
  }),
);

// Error handling middleware
app.onError((err, c) => {
  console.error("Error:", err);
  const errorResponse = formatErrorResponse(err);
  return c.json(errorResponse, errorResponse.statusCode as any);
});

// Validation helpers
function validateCreateSandbox(body: any): {
  valid: boolean;
  data?: { owner: string; repo: string; branch?: string };
  error?: string;
} {
  if (!body || typeof body !== "object") {
    return { valid: false, error: "Request body must be an object" };
  }
  if (
    !body.owner ||
    typeof body.owner !== "string" ||
    body.owner.length === 0
  ) {
    return {
      valid: false,
      error: "owner is required and must be a non-empty string",
    };
  }
  if (!body.repo || typeof body.repo !== "string" || body.repo.length === 0) {
    return {
      valid: false,
      error: "repo is required and must be a non-empty string",
    };
  }
  if (body.branch !== undefined && typeof body.branch !== "string") {
    return { valid: false, error: "branch must be a string" };
  }
  return {
    valid: true,
    data: {
      owner: body.owner,
      repo: body.repo,
      branch: body.branch,
    },
  };
}

// Routes

/**
 * Health check endpoint
 */
app.get("/health", (c) => {
  const activeSessions = sessionManager.getActiveCount();
  return c.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    provider: config.sandbox.provider,
    activeSessions,
  });
});

/**
 * Create a new sandbox for a repository
 * POST /api/sandbox/create
 */
app.post("/api/sandbox/create", async (c) => {
  const body = await c.req.json();
  const validation = validateCreateSandbox(body);

  if (!validation.valid) {
    return c.json({ error: "ValidationError", message: validation.error }, 400);
  }

  const { owner, repo, branch } = validation.data!;

  console.log(
    `ğŸ“¦ Creating sandbox for ${owner}/${repo}${branch ? `@${branch}` : ""}`,
  );

  // Check if we've hit the concurrent limit
  if (sessionManager.getActiveCount() >= config.sandbox.maxConcurrent) {
    return c.json(
      {
        error: "ResourceLimitError",
        message:
          "Maximum concurrent sandboxes reached. Please try again later.",
      },
      429,
    );
  }

  // Check if session already exists for this repo
  const existingSession = sessionManager.findByRepo(owner, repo);
  if (existingSession && existingSession.status === "ready") {
    console.log(`  â™»ï¸  Reusing existing session: ${existingSession.id}`);
    return c.json({
      sessionId: existingSession.id,
      status: existingSession.status,
      url: existingSession.sandboxUrl,
      reused: true,
    });
  }

  // Validate repository exists
  console.log(`  ğŸ” Validating repository...`);
  const isValid = await githubClient.validateRepository(owner, repo);
  if (!isValid) {
    return c.json(
      {
        error: "ValidationError",
        message: `Repository ${owner}/${repo} not found or not accessible`,
      },
      404,
    );
  }

  // Get repository metadata
  const metadata = await githubClient.getRepositoryMetadata(owner, repo);
  console.log(`  âœ… Repository validated: ${metadata.fullName}`);

  // Create session
  const session = sessionManager.create(
    owner,
    repo,
    config.sandbox.provider,
    config.sandbox.sessionTimeout,
  );
  console.log(`  ğŸ†” Session created: ${session.id}`);

  // Provision sandbox asynchronously
  (async () => {
    try {
      console.log(`  ğŸš€ Provisioning sandbox...`);
      const result = await sandboxProvider.provision({
        sessionId: session.id,
        owner,
        repo,
        branch: branch || metadata.defaultBranch,
        cloneUrl: metadata.cloneUrl,
      });

      // Update session with sandbox info
      sessionManager.update(session.id, {
        sandboxUrl: result.url,
        status: result.status,
        containerId: result.id,
      });

      console.log(`  âœ… Sandbox ready: ${result.url}`);
    } catch (error) {
      console.error(`  âŒ Sandbox provisioning failed:`, error);
      sessionManager.update(session.id, {
        status: "error",
        error: error instanceof Error ? error.message : String(error),
      });
    }
  })();

    return c.json({
      sessionId: session.id,
      status: "provisioning",
      estimatedTime: 30, // seconds
    });
  });
    }

    return c.json({
      sessionId: session.id,
      status: session.status,
      url: session.sandboxUrl,
      owner: session.owner,
      repo: session.repo,
      provider: session.provider,
      createdAt: session.createdAt,
      expiresAt: session.expiresAt,
      error: session.error,
    });
  });

/**
 * Get sandbox status
 * GET /api/sandbox/:sessionId
 */
app.get("/api/sandbox/:sessionId", async (c) => {
  const sessionId = c.req.param("sessionId");

  if (!sessionId) {
    return c.json({ error: "ValidationError", message: "sessionId is required" }, 400);
  }

    const session = sessionManager.get(sessionId);
    if (!session) {
      return c.json(
        {
          error: "SessionNotFoundError",
          message: `Session ${sessionId} not found`,
        },
        404,
      );
    }

    // Terminate sandbox
    if (session.containerId || session.workspaceId) {
      const id = session.containerId || session.workspaceId!;
      await sandboxProvider.terminate(id);
    }

    // Remove session
    sessionManager.delete(sessionId);

    return c.json({
      success: true,
      message: `Session ${sessionId} terminated`,
    });
  });

/**
 * Validate a repository (without creating sandbox)
 * GET /api/repo/validate
 */
app.get("/api/repo/validate", async (c) => {
  const owner = c.req.query("owner");
  const repo = c.req.query("repo");

  if (!owner || !repo) {
    return c.json(
      {
        error: "ValidationError",
        message: "Both 'owner' and 'repo' query parameters are required",
      },
      400,
    );
  }

  const isValid = await githubClient.validateRepository(owner, repo);

  if (!isValid) {
    return c.json({
      valid: false,
      message: `Repository ${owner}/${repo} not found or not accessible`,
    });
  }

  const metadata = await githubClient.getRepositoryMetadata(owner, repo);

  return c.json({
    valid: true,
    metadata,
  });
});

/**
 * List all active sessions
 * GET /api/sandbox
 */
app.get("/api/sandbox", (c) => {
  const sessions = sessionManager.list();

  return c.json({
    total: sessions.length,
    sessions: sessions.map((s) => ({
      sessionId: s.id,
      owner: s.owner,
      repo: s.repo,
      status: s.status,
      url: s.sandboxUrl,
      createdAt: s.createdAt,
      expiresAt: s.expiresAt,
    })),
  });
});

export default app;

// Cleanup worker - runs every minute
setInterval(() => {
  const expired = sessionManager.cleanup();
  if (expired.length > 0) {
    console.log(`ğŸ§¹ Cleaned up ${expired.length} expired sessions`);
    // Terminate their sandboxes
    for (const session of expired) {
      if (session.containerId || session.workspaceId) {
        const id = session.containerId || session.workspaceId!;
        sandboxProvider.terminate(id).catch((err) => {
          console.error(`Failed to terminate sandbox ${id}:`, err);
        });
      }
    }
  }
}, 60000); // Every minute

// If running as a standalone server
if (import.meta.main) {
  const port = config.server.port;
  const host = config.server.host;

  console.log("\n" + "=".repeat(60));
  console.log("ğŸš€ Open GitHub Backend Server");
  console.log("=".repeat(60));
  console.log(`\nğŸ“ Server: http://${host}:${port}`);
  console.log(`ğŸ³ Provider: ${config.sandbox.provider}`);
  console.log(`â±ï¸  Session timeout: ${config.sandbox.sessionTimeout}s`);
  console.log(`ğŸ”¢ Max concurrent: ${config.sandbox.maxConcurrent}`);
  console.log(`ğŸŒ CORS origins: ${config.server.allowedOrigins.join(", ")}`);
  console.log("\n" + "=".repeat(60) + "\n");

  Bun.serve({
    port,
    hostname: host,
    fetch: app.fetch,
  });
}
